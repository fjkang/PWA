var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var idb = createCommonjsModule(function (module) {
'use strict';

(function() {
  function toArray(arr) {
    return Array.prototype.slice.call(arr);
  }

  function promisifyRequest(request) {
    return new Promise(function(resolve, reject) {
      request.onsuccess = function() {
        resolve(request.result);
      };

      request.onerror = function() {
        reject(request.error);
      };
    });
  }

  function promisifyRequestCall(obj, method, args) {
    var request;
    var p = new Promise(function(resolve, reject) {
      request = obj[method].apply(obj, args);
      promisifyRequest(request).then(resolve, reject);
    });

    p.request = request;
    return p;
  }

  function promisifyCursorRequestCall(obj, method, args) {
    var p = promisifyRequestCall(obj, method, args);
    return p.then(function(value) {
      if (!value) return;
      return new Cursor(value, p.request);
    });
  }

  function proxyProperties(ProxyClass, targetProp, properties) {
    properties.forEach(function(prop) {
      Object.defineProperty(ProxyClass.prototype, prop, {
        get: function() {
          return this[targetProp][prop];
        },
        set: function(val) {
          this[targetProp][prop] = val;
        }
      });
    });
  }

  function proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {
    properties.forEach(function(prop) {
      if (!(prop in Constructor.prototype)) return;
      ProxyClass.prototype[prop] = function() {
        return promisifyRequestCall(this[targetProp], prop, arguments);
      };
    });
  }

  function proxyMethods(ProxyClass, targetProp, Constructor, properties) {
    properties.forEach(function(prop) {
      if (!(prop in Constructor.prototype)) return;
      ProxyClass.prototype[prop] = function() {
        return this[targetProp][prop].apply(this[targetProp], arguments);
      };
    });
  }

  function proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {
    properties.forEach(function(prop) {
      if (!(prop in Constructor.prototype)) return;
      ProxyClass.prototype[prop] = function() {
        return promisifyCursorRequestCall(this[targetProp], prop, arguments);
      };
    });
  }

  function Index(index) {
    this._index = index;
  }

  proxyProperties(Index, '_index', [
    'name',
    'keyPath',
    'multiEntry',
    'unique'
  ]);

  proxyRequestMethods(Index, '_index', IDBIndex, [
    'get',
    'getKey',
    'getAll',
    'getAllKeys',
    'count'
  ]);

  proxyCursorRequestMethods(Index, '_index', IDBIndex, [
    'openCursor',
    'openKeyCursor'
  ]);

  function Cursor(cursor, request) {
    this._cursor = cursor;
    this._request = request;
  }

  proxyProperties(Cursor, '_cursor', [
    'direction',
    'key',
    'primaryKey',
    'value'
  ]);

  proxyRequestMethods(Cursor, '_cursor', IDBCursor, [
    'update',
    'delete'
  ]);

  // proxy 'next' methods
  ['advance', 'continue', 'continuePrimaryKey'].forEach(function(methodName) {
    if (!(methodName in IDBCursor.prototype)) return;
    Cursor.prototype[methodName] = function() {
      var cursor = this;
      var args = arguments;
      return Promise.resolve().then(function() {
        cursor._cursor[methodName].apply(cursor._cursor, args);
        return promisifyRequest(cursor._request).then(function(value) {
          if (!value) return;
          return new Cursor(value, cursor._request);
        });
      });
    };
  });

  function ObjectStore(store) {
    this._store = store;
  }

  ObjectStore.prototype.createIndex = function() {
    return new Index(this._store.createIndex.apply(this._store, arguments));
  };

  ObjectStore.prototype.index = function() {
    return new Index(this._store.index.apply(this._store, arguments));
  };

  proxyProperties(ObjectStore, '_store', [
    'name',
    'keyPath',
    'indexNames',
    'autoIncrement'
  ]);

  proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [
    'put',
    'add',
    'delete',
    'clear',
    'get',
    'getAll',
    'getKey',
    'getAllKeys',
    'count'
  ]);

  proxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, [
    'openCursor',
    'openKeyCursor'
  ]);

  proxyMethods(ObjectStore, '_store', IDBObjectStore, [
    'deleteIndex'
  ]);

  function Transaction(idbTransaction) {
    this._tx = idbTransaction;
    this.complete = new Promise(function(resolve, reject) {
      idbTransaction.oncomplete = function() {
        resolve();
      };
      idbTransaction.onerror = function() {
        reject(idbTransaction.error);
      };
      idbTransaction.onabort = function() {
        reject(idbTransaction.error);
      };
    });
  }

  Transaction.prototype.objectStore = function() {
    return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));
  };

  proxyProperties(Transaction, '_tx', [
    'objectStoreNames',
    'mode'
  ]);

  proxyMethods(Transaction, '_tx', IDBTransaction, [
    'abort'
  ]);

  function UpgradeDB(db, oldVersion, transaction) {
    this._db = db;
    this.oldVersion = oldVersion;
    this.transaction = new Transaction(transaction);
  }

  UpgradeDB.prototype.createObjectStore = function() {
    return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));
  };

  proxyProperties(UpgradeDB, '_db', [
    'name',
    'version',
    'objectStoreNames'
  ]);

  proxyMethods(UpgradeDB, '_db', IDBDatabase, [
    'deleteObjectStore',
    'close'
  ]);

  function DB(db) {
    this._db = db;
  }

  DB.prototype.transaction = function() {
    return new Transaction(this._db.transaction.apply(this._db, arguments));
  };

  proxyProperties(DB, '_db', [
    'name',
    'version',
    'objectStoreNames'
  ]);

  proxyMethods(DB, '_db', IDBDatabase, [
    'close'
  ]);

  // Add cursor iterators
  // TODO: remove this once browsers do the right thing with promises
  ['openCursor', 'openKeyCursor'].forEach(function(funcName) {
    [ObjectStore, Index].forEach(function(Constructor) {
      Constructor.prototype[funcName.replace('open', 'iterate')] = function() {
        var args = toArray(arguments);
        var callback = args[args.length - 1];
        var nativeObject = this._store || this._index;
        var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));
        request.onsuccess = function() {
          callback(request.result);
        };
      };
    });
  });

  // polyfill getAll
  [Index, ObjectStore].forEach(function(Constructor) {
    if (Constructor.prototype.getAll) return;
    Constructor.prototype.getAll = function(query, count) {
      var instance = this;
      var items = [];

      return new Promise(function(resolve) {
        instance.iterateCursor(query, function(cursor) {
          if (!cursor) {
            resolve(items);
            return;
          }
          items.push(cursor.value);

          if (count !== undefined && items.length == count) {
            resolve(items);
            return;
          }
          cursor.continue();
        });
      });
    };
  });

  var exp = {
    open: function(name, version, upgradeCallback) {
      var p = promisifyRequestCall(indexedDB, 'open', [name, version]);
      var request = p.request;

      request.onupgradeneeded = function(event) {
        if (upgradeCallback) {
          upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));
        }
      };

      return p.then(function(db) {
        return new DB(db);
      });
    },
    delete: function(name) {
      return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);
    }
  };

  {
    module.exports = exp;
    module.exports.default = module.exports;
  }
}());
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-disable require-jsdoc */

/**
 * A wrapper to store for an IDB connection to a particular ObjectStore.
 *
 * @private
 */
class IDBHelper {
  constructor(name, version, storeName) {
    if (name == undefined || version == undefined || storeName == undefined) {
      throw Error('name, version, storeName must be passed to the ' +
        'constructor.');
    }

    this._name = name;
    this._version = version;
    this._storeName = storeName;
  }

  /**
   * Returns a promise that resolves with an open connection to IndexedDB,
   * either existing or newly opened.
   *
   * @private
   * @return {Promise<DB>}
   */
  _getDb() {
    if (this._dbPromise) {
      return this._dbPromise;
    }

    this._dbPromise = idb.open(this._name, this._version, (upgradeDB) => {
      upgradeDB.createObjectStore(this._storeName);
    })
    .then((db) => {
      return db;
    });

    return this._dbPromise;
  }

  close() {
    if (!this._dbPromise) {
      return;
    }

    return this._dbPromise
    .then((db) => {
      db.close();
      this._dbPromise = null;
    });
  }

  /**
   * Wrapper on top of the idb wrapper, which simplifies saving the key/value
   * pair to the object store.
   * Returns a Promise that fulfills when the transaction completes.
   *
   * @private
   * @param {String} key
   * @param {Object} value
   * @return {Promise<T>}
   */
  put(key, value) {
    return this._getDb().then((db) => {
      const tx = db.transaction(this._storeName, 'readwrite');
      const objectStore = tx.objectStore(this._storeName);
      objectStore.put(value, key);
      return tx.complete;
    });
  }

  /**
   * Wrapper on top of the idb wrapper, which simplifies deleting an entry
   * from the object store.
   * Returns a Promise that fulfills when the transaction completes.
   *
   * @private
   * @param {String} key
   * @return {Promise<T>}
   */
  delete(key) {
    return this._getDb().then((db) => {
      const tx = db.transaction(this._storeName, 'readwrite');
      const objectStore = tx.objectStore(this._storeName);
      objectStore.delete(key);
      return tx.complete;
    });
  }

  /**
   * Wrapper on top of the idb wrapper, which simplifies getting a key's value
   * from the object store.
   * Returns a promise that fulfills with the value.
   *
   * @private
   * @param {String} key
   * @return {Promise<Object>}
   */
  get(key) {
    return this._getDb().then((db) => {
      return db.transaction(this._storeName)
        .objectStore(this._storeName)
        .get(key);
    });
  }

  /**
   * Wrapper on top of the idb wrapper, which simplifies getting all the values
   * in an object store.
   * Returns a promise that fulfills with all the values.
   *
   * @private
   * @return {Promise<Array<Object>>}
   */
  getAllValues() {
    return this._getDb().then((db) => {
      return db.transaction(this._storeName)
        .objectStore(this._storeName)
        .getAll();
    });
  }

  /**
   * Wrapper on top of the idb wrapper, which simplifies getting all the keys
   * in an object store.
   * Returns a promise that fulfills with all the keys.
   *
   * @private
   * @param {String} storeName
   * @return {Promise<Array<Object>>}
   */
  getAllKeys() {
    return this._getDb().then((db) => {
      return db.transaction(this._storeName)
        .objectStore(this._storeName)
        .getAllKeys();
    });
  }
}

/* eslint-disable no-console */

/**
 * A simple helper to manage the print of a set of logs
 */
class LogGroup {
  /**
   * @param {object} input
   */
  constructor() {
    this._logs = [];
    this._childGroups = [];

    this._isFallbackMode = false;
    const ffRegex = /Firefox\/(\d*)\.\d*/.exec(navigator.userAgent);
    if (ffRegex) {
      try {
        const ffVersion = parseInt(ffRegex[1], 10);
        if (ffVersion < 55) {
          this._isFallbackMode = true;
        }
      } catch (err) {
        this._isFallbackMode = true;
      }
    }

    if (/Edge\/\d*\.\d*/.exec(navigator.userAgent)) {
      this._isFallbackMode = true;
    }
  }

  /**
   *@param {object} logDetails
   */
  addPrimaryLog(logDetails) {
    this._primaryLog = logDetails;
  }

  /**
   *@param {object} logDetails
   */
  addLog(logDetails) {
    this._logs.push(logDetails);
  }

  /**
   * @param {object} group
   */
  addChildGroup(group) {
    if (group._logs.length === 0) {
      return;
    }

    this._childGroups.push(group);
  }

  /**
   * prints out this log group to the console.
   */
  print() {
    if (this._logs.length === 0 && this._childGroups.length === 0) {
      this._printLogDetails(this._primaryLog);
      return;
    }

    if (this._primaryLog) {
      if (!this._isFallbackMode) {
        console.groupCollapsed(...this._getLogContent(this._primaryLog));
      } else {
        this._printLogDetails(this._primaryLog);
      }
    }

    this._logs.forEach((logDetails) => {
      this._printLogDetails(logDetails);
    });

    this._childGroups.forEach((group) => {
      group.print();
    });

    if (this._primaryLog && !this._isFallbackMode) {
      console.groupEnd();
    }
  }

  /**
   * Prints the specific logDetails object.
   * @param {object} logDetails
   */
  _printLogDetails(logDetails) {
    const logFunc = logDetails.logFunc ? logDetails.logFunc : console.log;
    logFunc(...this._getLogContent(logDetails));
  }

  /**
   * Returns a flattened array of message with colors and args.
   * @param {object} logDetails
   * @return {Array} Returns an array of arguments to pass to a console
   * function.
   */
  _getLogContent(logDetails) {
    let message = logDetails.message;
    if (this._isFallbackMode && typeof message === 'string') {
      // Replace the %c value with an empty string.
      message = message.replace(/%c/g, '');
    }

    let allArguments = [message];

    if (!this._isFallbackMode && logDetails.colors) {
      allArguments = allArguments.concat(logDetails.colors);
    }

    if (logDetails.args) {
      allArguments = allArguments.concat(logDetails.args);
    }
    return allArguments;
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * @private
 * @return {boolean} True, if we're running in the service worker global scope.
 * False otherwise.
 */


/**
 * @private
 * @return {boolean} True, if we're running a development bundle.
 * False otherwise.
 */
function isDevBuild() {
  // `BUILD_PROCESS_REPLACE::BUILD_TARGET` is replaced during the build process.
  return `BUILD_PROCESS_REPLACE::BUILD_TARGET` === `dev`;
}

/**
 * @private
 * @return {boolean} True, if we're running on localhost or the equivalent IP
 * address. False otherwise.
 */

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-disable no-console */

self.workbox = self.workbox || {};
self.workbox.LOG_LEVEL = self.workbox.LOG_LEVEL || {
  none: -1,
  verbose: 0,
  debug: 1,
  warn: 2,
  error: 3,
};

const LIGHT_GREY = `#bdc3c7`;
const DARK_GREY = `#7f8c8d`;
const LIGHT_GREEN = `#2ecc71`;
const LIGHT_YELLOW = `#f1c40f`;
const LIGHT_RED = `#e74c3c`;
const LIGHT_BLUE = `#3498db`;

/**
 * A class that will only log given the current log level
 * defined by the developer.
 *
 * Define custom log level by setting `self.workbox.logLevel`.
 *
 * @example
 *
 * self.workbox.logLevel = self.workbox.LOG_LEVEL.verbose;
 *
 * @private
 */
class LogHelper {
  /**
   * LogHelper constructor.
   */
  constructor() {
    this._defaultLogLevel = isDevBuild() ?
      self.workbox.LOG_LEVEL.debug :
      self.workbox.LOG_LEVEL.warn;
  }

  /**
   * The most verbose log level.
   *
   * @param {Object} options The options of the log.
   */
  log(options) {
    this._printMessage(self.workbox.LOG_LEVEL.verbose, options);
  }

  /**
   * Useful for logs that are more exceptional that log()
   * but not severe.
   *
   * @param {Object} options The options of the log.
   */
  debug(options) {
    this._printMessage(self.workbox.LOG_LEVEL.debug, options);
  }

  /**
   * Warning messages.
   *
   * @param {Object} options The options of the log.
   */
  warn(options) {
    this._printMessage(self.workbox.LOG_LEVEL.warn, options);
  }

  /**
   * Error logs.
   *
   * @param {Object} options The options of the log.
   */
  error(options) {
    this._printMessage(self.workbox.LOG_LEVEL.error, options);
  }

  /**
   * Method to print to the console.
   * @param {number} logLevel
   * @param {Object} logOptions
   */
  _printMessage(logLevel, logOptions) {
    if (!this._shouldLogMessage(logLevel, logOptions)) {
      return;
    }

    const logGroups = this._getAllLogGroups(logLevel, logOptions);
    logGroups.print();
  }

  /**
   * Print a user friendly log to the console.
   * @param  {numer} logLevel A number from self.workbox.LOG_LEVEL
   * @param  {Object} logOptions Arguments to print to the console
   * @return {LogGroup} Returns a log group to print to the console.
   */
  _getAllLogGroups(logLevel, logOptions) {
    const topLogGroup = new LogGroup();

    const primaryMessage = this._getPrimaryMessageDetails(logLevel, logOptions);
    topLogGroup.addPrimaryLog(primaryMessage);

    if (logOptions.error) {
      const errorMessage = {
        message: logOptions.error,
        logFunc: console.error,
      };
      topLogGroup.addLog(errorMessage);
    }

    const extraInfoGroup = new LogGroup();
    if (logOptions.that && logOptions.that.constructor &&
      logOptions.that.constructor.name) {
      const className = logOptions.that.constructor.name;
      extraInfoGroup.addLog(
        this._getKeyValueDetails('class', className)
      );
    }

    if (logOptions.data) {
      if (typeof logOptions.data === 'object' &&
        !(logOptions.data instanceof Array)) {
        Object.keys(logOptions.data).forEach((keyName) => {
          extraInfoGroup.addLog(
            this._getKeyValueDetails(keyName, logOptions.data[keyName])
          );
        });
      } else {
        extraInfoGroup.addLog(
          this._getKeyValueDetails('additionalData', logOptions.data)
        );
      }
    }

    topLogGroup.addChildGroup(extraInfoGroup);

    return topLogGroup;
  }

  /**
   * This is a helper function to wrap key value pairss to a colored key
   * value string.
   * @param  {string} key
   * @param  {string} value
   * @return {Object} The object containing a message, color and Arguments
   * for the console.
   */
  _getKeyValueDetails(key, value) {
    return {
      message: `%c${key}: `,
      colors: [`color: ${LIGHT_BLUE}`],
      args: value,
    };
  }

  /**
   * Helper method to color the primary message for the log
   * @param  {number} logLevel   One of self.workbox.LOG_LEVEL
   * @param  {Object} logOptions Arguments to print to the console
   * @return {Object} Object containing the message and color info to print.
   */
  _getPrimaryMessageDetails(logLevel, logOptions) {
    let logLevelName;
    let logLevelColor;
    switch (logLevel) {
      case self.workbox.LOG_LEVEL.verbose:
        logLevelName = 'Info';
        logLevelColor = LIGHT_GREY;
        break;
      case self.workbox.LOG_LEVEL.debug:
        logLevelName = 'Debug';
        logLevelColor = LIGHT_GREEN;
        break;
      case self.workbox.LOG_LEVEL.warn:
        logLevelName = 'Warn';
        logLevelColor = LIGHT_YELLOW;
        break;
      case self.workbox.LOG_LEVEL.error:
        logLevelName = 'Error';
        logLevelColor = LIGHT_RED;
        break;
    }

    let primaryLogMessage = `%c🔧 %c[${logLevelName}]`;
    const primaryLogColors = [
      `color: ${LIGHT_GREY}`,
      `color: ${logLevelColor}`,
    ];

    let message;
    if (typeof logOptions === 'string') {
      message = logOptions;
    } else if (logOptions.message) {
      message = logOptions.message;
    }

    if (message) {
      message = message.replace(/\s+/g, ' ');
      primaryLogMessage += `%c ${message}`;
      primaryLogColors.push(`color: ${DARK_GREY}; font-weight: normal`);
    }

    return {
      message: primaryLogMessage,
      colors: primaryLogColors,
    };
  }

  /**
   * Test if the message should actually be logged.
   * @param {number} logLevel The level of the current log to be printed.
   * @param {Object|String} logOptions The options to log.
   * @return {boolean} Returns true of the message should be printed.
   */
  _shouldLogMessage(logLevel, logOptions) {
    if (!logOptions) {
      return false;
    }

    let minValidLogLevel = this._defaultLogLevel;
    if (self && self.workbox && typeof self.workbox.logLevel === 'number') {
      minValidLogLevel = self.workbox.logLevel;
    }

    if (minValidLogLevel === self.workbox.LOG_LEVEL.none ||
      logLevel < minValidLogLevel) {
      return false;
    }

    return true;
  }
}

var logHelper = new LogHelper();

/*
 Copyright 2017 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * Warns users that an old property is deprecated in favor of a new property
 * and aliases the old name to the new name.
 * @param {Object} obj The object containing the methods.
 * @param {string} oldName The method to deprecate.
 * @param {string} newName The new method replacing the deprecated method.
 * @param {string} ctx The context project/object to identify the method names.
 */
var deprecate = (obj, oldName, newName, ctx) => {
  if (Object.prototype.hasOwnProperty.call(obj, oldName)) {
    logHelper.warn(
        `${oldName} is deprecated; use ${newName} instead`, {Context: ctx});

    obj[newName] = obj[oldName];
  }
};

/**
 * Puts the fetched response in the IDB
 *
 * @param {Object} config
 * @private
 */
async function putResponse({hash, idbObject, response, idbQDb}) {
  const _idbQHelper = idbQDb;
  idbObject.response = {
    headers: JSON.stringify([...response.headers]),
    status: response.status,
    body: await response.blob(),
  };
  _idbQHelper.put(hash, idbObject);
}

/**
 * This function returns the fetched response for the given id of the request
 *
 * @memberof module:workbox-background-sync
 * @private
 * @param {String} id The ID of the request given back by the broaadcast
 * channel
 * @return {Object} response Fetched response of the request.
 */
async function getResponse({id, dbName}) {
  const _idbQHelper = new IDBHelper(dbName, 1, 'QueueStore');
  const object = await _idbQHelper.get(id);
  if (object && object.response) {
    return object.response;
  } else {
    return null;
  }
}

const maxAge = 5*24*60*60*1000; // 5days
const defaultDBName = 'bgQueueSyncDB';
const broadcastMessageAddedType = 'BACKGROUND_REQUESTED_ADDED';
const broadcastMessageFailedType = 'BACKGROUND_REQUESTED_FAILED';
const defaultQueueName = 'DEFAULT_QUEUE';
const tagNamePrefix = 'SW_BACKGROUND_QUEUE_TAG_';
const broadcastMeta = 'SW_BACKGROUND_SYNC_QUEUE';
const allQueuesPlaceholder = 'QUEUES';
const replayAllQueuesTag = 'SW_BACKGROUND_QUEUE_TAG_REPLAY';

/**
 * takes a request and gives back JSON object that is storable in IDB
 *
 * @param {Request} request request object to transform
 * into iDB storable object
 * @param {Object} config config object to be
 * stored along in the iDB
 * @return {Object} indexable object for iDB
 *
 * @memberOf RequestManager
 * @private
 */
async function getQueueableRequest({request, config}) {
  let requestObject={
    config,
    metadata: {
      creationTimestamp: Date.now(),
    },
  };
  requestObject.request = {
    url: request.url,
    headers: JSON.stringify([...request.headers]),
    mode: request.mode,
    method: request.method,
    redirect: request.redirect,
    credentials: request.credentials,
  };
  const requestBody = await request.text();
  if (requestBody.length > 0) {
    requestObject.request.body = requestBody;
  }
  return requestObject;
}

/**
 * takes an object and return a Request object to be executed by
 * the browser
 * @param {Object} idbRequestObject
 * @return {Request}
 * @private
 */
async function getFetchableRequest({idbRequestObject}) {
  let reqObject = {
    mode: idbRequestObject.mode,
    method: idbRequestObject.method,
    redirect: idbRequestObject.redirect,
    headers: new Headers(JSON.parse(idbRequestObject.headers)),
    credentials: idbRequestObject.credentials,
  };
  if (idbRequestObject.body) {
    reqObject.body = idbRequestObject.body;
  }
  return new Request(idbRequestObject.url, reqObject);
}

/**
 * clean up the queue, deleting all the tasks who are either damaged or
 * whose maxAge has expired
 *
 * @memberOf Queue
 * @private
 * @param {string} dbName Name of database to cleanup.
 * @return {Promise}
 */
async function cleanupQueue(dbName) {
  let db = new IDBHelper(dbName, 1, 'QueueStore');
  let queueObj = await db.get(allQueuesPlaceholder);

  if (!queueObj) {
    return null;
  }

  await Promise.all(queueObj.map(async (queueName) => {
    const requestQueues = await db.get(queueName);
    let itemsToKeep = [];
    let deletionPromises = [];
    await Promise.all(requestQueues.map(async (hash) => {
      const requestData = await db.get(hash);
      if (requestData && requestData.metadata
        && requestData.metadata.creationTimestamp + requestData.config.maxAge
          <= Date.now()) {
        // Delete items that are too old.
        deletionPromises.push(db.delete(hash));
      } else {
        // Keep elements whose definition exists in idb.
        itemsToKeep.push(hash);
      }
    }));
    await Promise.all(deletionPromises);
    db.put(queueName, itemsToKeep);
  }));
}

/**
 * Class to handle all the request related
 * transformations, replaying, event handling
 * broadcasting back to controlled pages etc.
 * @class
 * @private
 */
class RequestManager {
  /**
   * Initializes the request manager
   * stores the callbacks object, maintains config and
   * attaches event handler
   * @param {Object=} config
   *
   * @private
   */
  constructor({callbacks, queue} = {}) {
    callbacks = callbacks || {};

    // Rename deprecated callbacks.
    const ctx = 'workbox-background-sync.RequestManager.callbacks';
    deprecate(callbacks, 'onResponse', 'replayDidSucceed', ctx);
    deprecate(callbacks, 'onRetryFailure', 'replayDidFail', ctx);

    this._globalCallbacks = callbacks;
    this._queue = queue;
    this.attachSyncHandler();
  }

  /**
   * attaches sync handler to replay requests when
   * sync event is fired
   *
   * @private
   */
  attachSyncHandler() {
    self.addEventListener('sync', (event) => {
      if (event.tag === tagNamePrefix + this._queue.queueName
        || event.tag === replayAllQueuesTag) {
        event.waitUntil(this.replayRequests());
      }
    });
  }

  /**
   * function to play one single request given its hash
   *
   * @param {String} hash
   *
   * @return {Promise} Resolves if the request corresponding to the hash is
   * played successfully, rejects if it fails during the replay
   *
   *
   * @private
   */
  async replayRequest(hash) {
    try {
      const reqData = await this._queue.getRequestFromQueue({hash});
      if (reqData.response) {
        return;
      }
      const request = await getFetchableRequest({
        idbRequestObject: reqData.request,
      });
      const response = await fetch(request);
      if (!response.ok) {
        return Promise.reject(response);
      } else {
        // not blocking on putResponse.
        putResponse({
          hash,
          idbObject: reqData,
          response: response.clone(),
          idbQDb: this._queue.idbQDb,
        });
        if (this._globalCallbacks.replayDidSucceed) {
          this._globalCallbacks.replayDidSucceed(hash, response);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
  }

  /**
   * This function is to be called to replay all the requests
   * in the current queue. It will play all the requests and return a promise
   * based on the successfull execution of the requests.
   *
   * @return {Promise} Resolves if all requests are played successfully,
   * rejects if any of the request fails during the replay
   *
   * @private
   */
  async replayRequests() {
    const failedItems = [];
    for (let hash of this._queue.queue) {
      try {
        await this.replayRequest(hash);
      } catch (err) {
        if (this._globalCallbacks.replayDidFail) {
          this._globalCallbacks.replayDidFail(hash, err);
        }
        failedItems.push(err);
      }
    }
    return failedItems.length > 0 ?
      Promise.reject(failedItems) : Promise.resolve();
  }
}

var stackframe = createCommonjsModule(function (module, exports) {
(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (typeof undefined === 'function' && undefined.amd) {
        undefined('stackframe', [], factory);
    } else {
        module.exports = factory();
    }
}(commonjsGlobal, function() {
    'use strict';
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function _capitalize(str) {
        return str[0].toUpperCase() + str.substring(1);
    }

    function _getter(p) {
        return function() {
            return this[p];
        };
    }

    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
    var numericProps = ['columnNumber', 'lineNumber'];
    var stringProps = ['fileName', 'functionName', 'source'];
    var arrayProps = ['args'];

    var props = booleanProps.concat(numericProps, stringProps, arrayProps);

    function StackFrame(obj) {
        if (obj instanceof Object) {
            for (var i = 0; i < props.length; i++) {
                if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {
                    this['set' + _capitalize(props[i])](obj[props[i]]);
                }
            }
        }
    }

    StackFrame.prototype = {
        getArgs: function() {
            return this.args;
        },
        setArgs: function(v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },

        getEvalOrigin: function() {
            return this.evalOrigin;
        },
        setEvalOrigin: function(v) {
            if (v instanceof StackFrame) {
                this.evalOrigin = v;
            } else if (v instanceof Object) {
                this.evalOrigin = new StackFrame(v);
            } else {
                throw new TypeError('Eval Origin must be an Object or StackFrame');
            }
        },

        toString: function() {
            var functionName = this.getFunctionName() || '{anonymous}';
            var args = '(' + (this.getArgs() || []).join(',') + ')';
            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';
            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';
            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';
            return functionName + args + fileName + lineNumber + columnNumber;
        }
    };

    for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {
            return function(v) {
                this[p] = Boolean(v);
            };
        })(booleanProps[i]);
    }

    for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {
            return function(v) {
                if (!_isNumber(v)) {
                    throw new TypeError(p + ' must be a Number');
                }
                this[p] = Number(v);
            };
        })(numericProps[j]);
    }

    for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {
            return function(v) {
                this[p] = String(v);
            };
        })(stringProps[k]);
    }

    return StackFrame;
}));
});

var errorStackParser = createCommonjsModule(function (module, exports) {
(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (typeof undefined === 'function' && undefined.amd) {
        undefined('error-stack-parser', ['stackframe'], factory);
    } else {
        module.exports = factory(stackframe);
    }
}(commonjsGlobal, function ErrorStackParser(StackFrame) {
    'use strict';

    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+\:\d+/;
    var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+\:\d+|\(native\))/m;
    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;

    return {
        /**
         * Given an Error object, extract the most information from it.
         *
         * @param {Error} error object
         * @return {Array} of StackFrames
         */
        parse: function ErrorStackParser$$parse(error) {
            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
                return this.parseOpera(error);
            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                return this.parseV8OrIE(error);
            } else if (error.stack) {
                return this.parseFFOrSafari(error);
            } else {
                throw new Error('Cannot parse given Error object');
            }
        },

        // Separate line and column numbers from a string of the form: (URI:Line:Column)
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
            // Fail-fast but return locations like "(native)"
            if (urlLike.indexOf(':') === -1) {
                return [urlLike];
            }

            var regExp = /(.+?)(?:\:(\d+))?(?:\:(\d+))?$/;
            var parts = regExp.exec(urlLike.replace(/[\(\)]/g, ''));
            return [parts[1], parts[2] || undefined, parts[3] || undefined];
        },

        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(CHROME_IE_STACK_REGEXP);
            }, this);

            return filtered.map(function(line) {
                if (line.indexOf('(eval ') > -1) {
                    // Throw away eval information until we implement stacktrace.js/stackframe#8
                    line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^\()]*)|(\)\,.*$)/g, '');
                }
                var tokens = line.replace(/^\s+/, '').replace(/\(eval code/g, '(').split(/\s+/).slice(1);
                var locationParts = this.extractLocation(tokens.pop());
                var functionName = tokens.join(' ') || undefined;
                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];

                return new StackFrame({
                    functionName: functionName,
                    fileName: fileName,
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        },

        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !line.match(SAFARI_NATIVE_CODE_REGEXP);
            }, this);

            return filtered.map(function(line) {
                // Throw away eval information until we implement stacktrace.js/stackframe#8
                if (line.indexOf(' > eval') > -1) {
                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g, ':$1');
                }

                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
                    // Safari eval frames only have function names and nothing else
                    return new StackFrame({
                        functionName: line
                    });
                } else {
                    var tokens = line.split('@');
                    var locationParts = this.extractLocation(tokens.pop());
                    var functionName = tokens.join('@') || undefined;

                    return new StackFrame({
                        functionName: functionName,
                        fileName: locationParts[0],
                        lineNumber: locationParts[1],
                        columnNumber: locationParts[2],
                        source: line
                    });
                }
            }, this);
        },

        parseOpera: function ErrorStackParser$$parseOpera(e) {
            if (!e.stacktrace || (e.message.indexOf('\n') > -1 &&
                e.message.split('\n').length > e.stacktrace.split('\n').length)) {
                return this.parseOpera9(e);
            } else if (!e.stack) {
                return this.parseOpera10(e);
            } else {
                return this.parseOpera11(e);
            }
        },

        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n');
            var result = [];

            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(new StackFrame({
                        fileName: match[2],
                        lineNumber: match[1],
                        source: lines[i]
                    }));
                }
            }

            return result;
        },

        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n');
            var result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(
                        new StackFrame({
                            functionName: match[3] || undefined,
                            fileName: match[2],
                            lineNumber: match[1],
                            source: lines[i]
                        })
                    );
                }
            }

            return result;
        },

        // Opera 10.65+ Error.stack very similar to FF/Safari
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
            }, this);

            return filtered.map(function(line) {
                var tokens = line.split('@');
                var locationParts = this.extractLocation(tokens.pop());
                var functionCall = (tokens.shift() || '');
                var functionName = functionCall
                        .replace(/<anonymous function(: (\w+))?>/, '$2')
                        .replace(/\([^\)]*\)/g, '') || undefined;
                var argsRaw;
                if (functionCall.match(/\(([^\)]*)\)/)) {
                    argsRaw = functionCall.replace(/^[^\(]+\(([^\)]*)\)$/, '$1');
                }
                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?
                    undefined : argsRaw.split(',');

                return new StackFrame({
                    functionName: functionName,
                    args: args,
                    fileName: locationParts[0],
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        }
    };
}));
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-disable require-jsdoc */





function isInstance(object, expectedClass) {
  const parameter = Object.keys(object).pop();
  if (!(object[parameter] instanceof expectedClass)) {
    throwError(`The '${parameter}' parameter must be an instance of
      '${expectedClass.name}'`);
  }
}



function isType(object, expectedType) {
  const parameter = Object.keys(object).pop();
  const actualType = typeof object[parameter];
  if (actualType !== expectedType) {
    throwError(`The '${parameter}' parameter has the wrong type. (Expected:
      ${expectedType}, actual: ${actualType})`);
  }
}







function throwError(message) {
  // Collapse any newlines or whitespace into a single space.
  message = message.replace(/\s+/g, ' ');

  const error = new Error(message);
  error.name = 'assertion-failed';

  const stackFrames = errorStackParser.parse(error);

  // If, for some reason, we don't have all the stack information we need,
  // we'll just end up throwing a basic Error.
  if (stackFrames.length >= 3) {
    // Assuming we have the stack frames, set the message to include info
    // about what the underlying method was, and set the name to reflect
    // the assertion type that failed.
    error.message = `Invalid call to ${stackFrames[2].functionName}() — ` +
      message;
  }

  throw error;
}

/**
 * broadcasts the message with the given type and url
 *
 * @param {BroadcastChannel} broadcastChannel which is used to push the
 * updates on
 * @param {Object} input
 * @param {string} input.type Type of the message (either success or failure)
 * @param {string} input.url Url for which the request was queued
 * @private
 */
function broadcastMessage({broadcastChannel, type, url}) {
  if (!broadcastChannel) {
    return;
  }

  isInstance({broadcastChannel}, BroadcastChannel);
  isType({type}, 'string');
  isType({url}, 'string');

  broadcastChannel.postMessage({
    type: type,
    meta: broadcastMeta,
    payload: {
      url: url,
    },
  });
}

let _requestCounter = 0;
let _queueCounter = 0;

/**
 * Queue class to maintain and perform on the logical requests queue
 *
 * @class RequestQueue
 * @private
 */
class RequestQueue {
  /**
   * Creates an instance of RequestQueue.
   *
   * @param {Object} config
   *
   * @memberOf RequestQueue
   * @private
   */
  constructor({
    config,
    queueName = defaultQueueName + '_' + _queueCounter++,
    idbQDb,
    broadcastChannel,
    callbacks,
  }) {
    this._isQueueNameAddedToAllQueue = false;
    this._queueName = queueName;
    this._config = config;
    this._idbQDb = idbQDb;
    this._broadcastChannel = broadcastChannel;
    this._globalCallbacks = callbacks || {};
    this._queue = [];
    this.initQueue();
  }

  /**
   * initializes the queue from the IDB store
   *
   * @memberOf RequestQueue
   * @private
   */
  async initQueue() {
    const idbQueue = await this._idbQDb.get(this._queueName);
    if (idbQueue) {
      this._queue.push(...idbQueue);
    }
  }

  /**
   * adds the current queueName to all queue array
   *
   * @memberOf RequestQueue
   * @private
   */
  async addQueueNameToAllQueues() {
    if (!this._isQueueNameAddedToAllQueue) {
      let allQueues = await this._idbQDb.get(allQueuesPlaceholder);
      allQueues = allQueues || [];
      if (!allQueues.includes(this._queueName)) {
        allQueues.push(this._queueName);
      }
      this._idbQDb.put(allQueuesPlaceholder, allQueues);
      this._isQueueNameAddedToAllQueue = true;
    }
  }

  /**
   * saves the logical queue to IDB
   *
   * @memberOf RequestQueue
   * @private
   */
  async saveQueue() {
    await this._idbQDb.put(this._queueName, this._queue);
  }

  /**
   * push any request to background sync queue which would be played later
   * preferably when network comes back
   *
   * @param {Request} request request object to be queued by this
   * @return {Promise}
   *
   * @memberOf Queue
   * @private
   */
  async push({request}) {
    isInstance({request}, Request);

    const hash = `${request.url}!${Date.now()}!${_requestCounter++}`;
    const reqData = await getQueueableRequest({
      request,
      config: this._config,
    });

    // Apply the `requestWillEnqueue` callback so plugins can modify the
    // request data before it's stored in IndexedDB.
    if (this._globalCallbacks.requestWillEnqueue) {
      this._globalCallbacks.requestWillEnqueue(reqData);
    }

    try {
      this._queue.push(hash);

      // add to queue
      this.saveQueue();
      this._idbQDb.put(hash, reqData);
      await this.addQueueNameToAllQueues();
      // register sync
      self.registration &&
        self.registration.sync.register(tagNamePrefix + this._queueName);

      // broadcast the success of request added to the queue
      broadcastMessage({
        broadcastChannel: this._broadcastChannel,
        type: broadcastMessageAddedType,
        id: hash,
        url: request.url,
      });

      return hash;
    } catch (err) {
      // broadcast the failure of request added to the queue
      broadcastMessage({
        broadcastChannel: this._broadcastChannel,
        type: broadcastMessageFailedType,
        id: hash,
        url: request.url,
      });

      return err;
    }
  }

  /**
   * get the Request from the queue at a particular index
   *
   * @param {string} hash hash of the request at the given index
   * @return {Promise<Object>} request object corresponding to given hash
   * @memberOf Queue
   * @private
   */
  async getRequestFromQueue({hash}) {
    isType({hash}, 'string');

    if (this._queue.includes(hash)) {
      const reqData = await this._idbQDb.get(hash);

      // Apply the `requestWillDequeue` callback so plugins can modify the
      // stored data before it's converted back into a request to be replayed.
      if (this._globalCallbacks.requestWillDequeue) {
        this._globalCallbacks.requestWillDequeue(reqData);
      }

      return reqData;
    }
  }

  /**
   * returns the instance of queue.
   *
   * @readonly
   *
   * @memberOf RequestQueue
   * @private
   */
  get queue() {
    return Object.assign([], this._queue);
  }

  /**
   * returns the name of the current queue
   *
   * @readonly
   *
   * @memberOf RequestQueue
   * @private
   */
  get queueName() {
    return this._queueName;
  }

  /**
   * returns the instance of IDBStore
   *
   * @readonly
   *
   * @memberOf RequestQueue
   * @private
   */
  get idbQDb() {
    return this._idbQDb;
  }
}

/**
 * Use the instance of this class to push the failed requests into the queue.
 *
 * @example
 * When you want to push the requests manually
 * let bgQueue = new workbox.backgroundSync.Queue();
 * self.addEventListener('fetch', function(e) {
 *   if (!e.request.url.startsWith('https://jsonplaceholder.typicode.com')) {
 *     return;
 *   }
 *
 *   const clone = e.request.clone();
 *   e.respondWith(fetch(e.request).catch((err) => {
 *     bgQueue.pushIntoQueue({
 *       request: clone,
 *     });
 *     throw err;
 *   }));
 * });
 *
 * @memberof module:workbox-background-sync
 */
class Queue {
  /**
   * Creates an instance of Queue with the given options
   *
   * @param {Object} [input]
   * @param {Number} [input.maxRetentionTime = 5 days] Time for which a queued
   * request will live in the queue(irrespective of failed/success of replay).
   * @param {Object} [input.callbacks] Callbacks for successfull/failed
   * replay of a request as well as modifying before enqueue/dequeue-ing.
   * @param {Fuction} [input.callbacks.replayDidSucceed]
   * Invoked with params (hash:string, response:Response) after a request is
   * successfully replayed.
   * @param {Fuction<string>} [input.callbacks.replayDidFail]
   * Invoked with param (hash:string) after a replay attempt has failed.
   * @param {Fuction<Object>} [input.callbacks.requestWillEnqueue]
   * Invoked with param (reqData:Object) before a failed request is saved to
   * the queue. Use this to modify the saved data.
   * @param {Fuction<Object>} [input.callbacks.requestWillDequeue]
   * Invoked with param (reqData:Object) before a failed request is retrieved
   * from the queue. Use this to modify the data before the request is replayed.
   * @param {string} [input.queueName] Queue name inside db in which
   * requests will be queued.
   * @param {BroadcastChannel=} [input.broadcastChannel] BroadcastChannel
   * which will be used to publish messages when the request will be queued.
   */
  constructor({
    broadcastChannel,
    callbacks,
    queueName,
    dbName = defaultDBName,
    maxRetentionTime = maxAge,
  } = {}) {
  if (queueName) {
    isType({queueName}, 'string');
  }

    if (maxRetentionTime) {
      isType({maxRetentionTime}, 'number');
    }

    if (broadcastChannel) {
      isInstance({broadcastChannel}, BroadcastChannel);
    }

    isType({dbName}, 'string');

    this._dbName = dbName;
    this._queue = new RequestQueue({
      config: {
        maxAge: maxRetentionTime,
      },
      queueName,
      idbQDb: new IDBHelper(this._dbName, 1, 'QueueStore'),
      broadcastChannel,
      callbacks,
    });
    this._requestManager = new RequestManager({
      callbacks,
      queue: this._queue,
    });

    this.cleanupQueue();
  }

  /**
   * clean up the queue, deleting all the tasks whose maxAge has expired
   *
   * @memberOf Queue
   * @private
   * @return {Promise}
   */
  cleanupQueue() {
    return cleanupQueue(this._dbName);
  }

  /**
   * This function pushes a given request into the IndexedDb Queue.
   *
   * @param {Object} input
   * @param {Request} input.request The request which is to be queued
   *
   * @return {Promise} Promise which resolves when the request is pushed in
   * the queue.
   */
  pushIntoQueue({request}) {
    isInstance({request}, Request);
    return this._queue.push({request});
  }

  /**
   * Replays all the requests in the queue, this can be used for custom timing
   * of replaying requests may be in an environment where sync event is not
   * supported.
   * @return {Promise} A listener for when the requests have been replayed.
   */
  replayRequests() {
    return this._requestManager.replayRequests();
  }

  /**
   * Sets the dbName, which is used to store the queue and requests
   * defaults to bgQueueSyncDB.
   * @param {String} id The ID of the request.
   * @return {Object} Fetched response of the request.
   */
  getResponse({id}) {
    return getResponse({
      id,
      dbName: this._dbName,
    });
  }
}

/**
 * Use the instance of this class to push the failed requests into the queue.
 *
 * @example <caption>When you want the workbox-sw framework to take care of
 * failed requests.</caption>
 * let bgQueue = new workbox.backgroundSync.QueuePlugin({
 *   callbacks: {
 *     replayDidSucceed: async(hash, res) => {
 *       self.registration.showNotification('Background sync demo', {
 *         body: 'Product has been purchased.',
 *         icon: '/images/shop-icon-384.png',
 *        });
 *     },
 *     replayDidFail: (hash) => {},
 *     requestWillEnqueue: (reqData) => {},
 *     requestWillDequeue: (reqData) => {},
 *   },
 * });
 *
 * const requestWrapper = new workbox.runtimeCaching.RequestWrapper({
 *   plugins: [bgQueue],
 * });
 *
 * const route = new workbox.routing.RegExpRoute({
 *   regExp: new RegExp('^https://jsonplaceholder.typicode.com'),
 *   handler: new workbox.runtimeCaching.NetworkOnly({requestWrapper}),
 * });
 *
 * const router = new workbox.routing.Router();
 * router.registerRoute({route});
 *
 * @memberof module:workbox-background-sync
 * @extends module:workbox-background-sync.Queue
 */
class QueuePlugin extends Queue {
  /**
   * Wraps `pushIntoQueue` in a callback used by higher level framework.
   * This function pushes a given request into the IndexedDb Queue.
   * NOTE: If you are writting the fetch handler for background sync manually,
   * please ignore this.
   *
   * @param {Object} input
   * @param {Request} input.request The request which is to be queued
   *
   * @return {Promise} Promise which resolves when the request is pushed in
   * the queue.
   */
  fetchDidFail({request}) {
    return this.pushIntoQueue({request});
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

describe(`background-sync-queue-plugin`, function() {
  const db = new IDBHelper(defaultDBName, 1, 'QueueStore');
  const resetDb = async function() {
    const keys = await db.getAllKeys();
    return Promise.all(keys.map((key) => db.delete(key)));
  };

  before(resetDb);
  afterEach(resetDb);

  it(`should add the request to queue when fetch fails`, async function() {
    const backgroundSyncQueue = new QueuePlugin({});
    const currentLen = backgroundSyncQueue._queue.queue.length;

    await backgroundSyncQueue.fetchDidFail({
      request: new Request('http://lipsum.com'),
    });
    expect(backgroundSyncQueue._queue.queue.length).to.equal(currentLen + 1);
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

function delay(timeout) {
  return new Promise((resolve, reject) => {
    setTimeout(() => resolve(), timeout);
  });
}

describe(`background sync queue`, function() {
  let responseAchieved = 0;
  function onRes() {
    responseAchieved = responseAchieved + 1;
  }
  function onRetryFail() {}

  const QUEUE_NAME = 'QUEUE_NAME';
  const MAX_AGE = 6;
  const CALLBACKS = {
    onResponse: onRes,
    onRetryFail: onRetryFail,
  };

  let backgroundSyncQueue;

  beforeEach(async function() {
    responseAchieved = 0;
    backgroundSyncQueue = new Queue({
      maxRetentionTime: MAX_AGE,
      callbacks: CALLBACKS,
    });
  });

  afterEach(async function() {
    // replay queue so that further tests are not affected
    try {
      await backgroundSyncQueue.replayRequests();
    } catch (e) {
      // do nothing as this is just a cleanup exercise
    }
    await backgroundSyncQueue.cleanupQueue();
  });

  it(`should get default values if nothing is given in constructor`, function() {
    const defaultsBackgroundSyncQueue = new Queue({});
    expect(defaultsBackgroundSyncQueue._queue).to.be.an('object');
    expect(defaultsBackgroundSyncQueue._requestManager).to.be.an('object');
    expect(defaultsBackgroundSyncQueue._queue._queueName).to.be
        .equal(defaultQueueName + '_2');
    expect(defaultsBackgroundSyncQueue._queue._config.maxAge).to.be
        .equal(maxAge);
    expect(
        JSON.stringify(
            defaultsBackgroundSyncQueue._requestManager._globalCallbacks))
        .to.equal(JSON.stringify({}));
  });

  it(`should take values from when given in constructor`, function() {
    backgroundSyncQueue = new Queue({
      maxRetentionTime: MAX_AGE,
      queueName: QUEUE_NAME,
      callbacks: CALLBACKS,
    });
    expect(backgroundSyncQueue._queue).to.be.an('object');
    expect(backgroundSyncQueue._requestManager).to.be.an('object');
    expect(backgroundSyncQueue._queue._queueName).to.equal(QUEUE_NAME);
    expect(backgroundSyncQueue._queue._config.maxAge).to.equal(MAX_AGE);
    expect(backgroundSyncQueue._requestManager._globalCallbacks).to.be
        .equal(CALLBACKS);
  });

  it(`should push request in queue via pushIntoQueue method`, async function() {
    await backgroundSyncQueue.pushIntoQueue({
      request: new Request('/__echo/counter'),
    });
    expect(backgroundSyncQueue._queue.queue.length).to.equal(1);
  });

  it(`check replay queued request via replayRequests method`, async function() {
    await backgroundSyncQueue.pushIntoQueue({
      request: new Request('/__echo/counter'),
    });
    await backgroundSyncQueue.pushIntoQueue({
      request: new Request('/__echo/counter'),
    });
    expect(backgroundSyncQueue._queue.queue.length).to.equal(2);
    await backgroundSyncQueue.replayRequests();
    expect(responseAchieved).to.equal(2);
  });

  it(`should rejected promise on replay failure`, async function() {
    await backgroundSyncQueue.pushIntoQueue({
      request: new Request('/__echo/counter'),
    });
    await backgroundSyncQueue.pushIntoQueue({
      request: new Request('/__test/404'),
    });
    try {
      await backgroundSyncQueue.replayRequests();
      throw new Error('Replay should have failed because of invalid URL');
    } catch (err) {
      expect(err[0].status).to.equal(404);
    }
  });

  it(`should remove requests from queue which are post threir maxRetentionTime`, async function() {
    /* code for clearing everything from IDB */
    const backgroundSyncQueue
        = new Queue({
          maxRetentionTime: 1,
        });

    const backgroundSyncQueue2
        = new Queue({
          maxRetentionTime: 10000,
          dbName: 'Queue2',
        });

    await backgroundSyncQueue.cleanupQueue();
    await backgroundSyncQueue2.cleanupQueue();
    await backgroundSyncQueue.pushIntoQueue({
      request: new Request('/__echo/counter'),
    });
    await backgroundSyncQueue.pushIntoQueue({
      request: new Request('/__echo/counter'),
    });
    await backgroundSyncQueue2.pushIntoQueue({
      request: new Request('/__echo/counter'),
    });
    const queue1Keys = (await backgroundSyncQueue._queue._idbQDb.getAllKeys());
    const queue2Keys = (await backgroundSyncQueue2._queue._idbQDb.getAllKeys());
    await delay(100);
    await backgroundSyncQueue.cleanupQueue();
    await backgroundSyncQueue2.cleanupQueue();
    const expectedQueue1Keys =
        (await backgroundSyncQueue._queue._idbQDb.getAllKeys()).length + 2;
    const expectedQueue2Keys =
        (await backgroundSyncQueue2._queue._idbQDb.getAllKeys()).length;
    expect(queue1Keys.length).to.equal(expectedQueue1Keys);
    expect(queue2Keys.length).to.equal(expectedQueue2Keys);
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

describe(`broadcast manager`, function() {
  it(`should broadcast message on given channel name`, function(done) {
    this.timeout(100);
    let msgRead = false;
    const channelName = 'CHANNEL';
    const testBroadcastChannel = new BroadcastChannel(channelName);
    const testReceiverChannel = new BroadcastChannel(channelName);
    testReceiverChannel.onmessage = function() {
      msgRead = true;
      expect(msgRead).to.be.true;
      done();
    };
    broadcastMessage({
      broadcastChannel: testBroadcastChannel,
      type: 'SUCCESS',
      url: 'http://google.com',
    });
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * # workbox-background-sync
 *
 * A helper library that queues specified requests if they fail over network.
 * Later it uses the Background Sync API to replay these queued requests
 * when the network state has changed.
 *
 * The main use of this module will be instantiating a new
 * [QueuePlugin]{@link module:workbox-background-sync.QueuePlugin} and passing
 * it to a {@link module:workbox-runtime-caching.RequestWrapper|RequestWrapper},
 * as shown in the first example below.
 *
 * @example <caption>Using the QueuePlugin class in a service worker.</caption>
 *
 * let bgQueue = new workbox.backgroundSync.QueuePlugin();
 * const requestWrapper = new workbox.runtimeCaching.RequestWrapper({
 *   plugins: [bgQueue],
 * });
 *
 * const route = new workbox.routing.RegExpRoute({
 *   regExp: new RegExp('^http://localhost:3000/__echo/counter'),
 *   handler: new workbox.runtimeCaching.NetworkOnly({requestWrapper}),
 * });
 *
 * const router = new workbox.routing.Router();
 * router.registerRoute({route});
 *
 * @module workbox-background-sync
 */



var namespace = Object.freeze({
	Queue: Queue,
	QueuePlugin: QueuePlugin
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

const exportedSymbols = [
  'Queue',
  'QueuePlugin',
];

describe(`Test Library Surface`, function() {
  exportedSymbols.forEach((exportedSymbol) => {
    it(`should expose ${exportedSymbol} publicly`, function() {
      expect(namespace[exportedSymbol]).to.exist;
    });
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

describe(`queue-utils`, function() {
  const maxAgeTimeStamp = 1000 * 60 * 60 * 24;
  const config = {
    maxAge: maxAgeTimeStamp,
  };

  const db = new IDBHelper(defaultDBName, 1, 'QueueStore');
  const resetDb = async () => {
    const keys = await db.getAllKeys();
    return Promise.all(keys.map((key) => db.delete(key)));
  };

  before(resetDb);
  afterEach(resetDb);

  it(`should be able to convert Request object to a javascript object`, function() {
    const request = new Request('http://localhost:3001/__echo/date-with-cors/random');
    return getQueueableRequest({
      request,
      config,
    }).then((reqObj) => {
      expect(reqObj).to.be.an('object');
      expect(reqObj.config).to.be.an('object');
      expect(reqObj.request).to.be.an('object');

      expect(reqObj.config.maxAge).to.equal(maxAgeTimeStamp);
      expect(reqObj.request.url).to.equal(request.url);
      expect(reqObj.request.mode).to.equal(request.mode);
      expect(reqObj.request.method).to.equal(request.method);
      expect(reqObj.request.redirect).to.equal(request.redirect);
    });
  });

  it(`should be able to convert a javascript object to Request object`, function() {
    const reqObj = {
      'url': 'http://localhost:3001/__echo/date-with-cors/random',
      'headers': '[]',
      'mode': 'cors',
      'method': 'GET',
      'redirect': 'follow',
    };

    return getFetchableRequest({idbRequestObject: reqObj})
      .then( (request) => {
        expect(reqObj.url).to.equal(request.url);
        expect(reqObj.mode).to.equal(request.mode);
        expect(reqObj.method).to.equal(request.method);
        expect(reqObj.redirect).to.equal(request.redirect);
      });
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

describe(`request-manager `, function() {
  const callbacks = {};
  let queue;
  let reqManager;

  const idbHelper = new IDBHelper(defaultDBName, 1, 'QueueStore');

  before(function(done) {
    const QUEUE_NAME = 'QUEUE_NAME';
    const MAX_AGE = 6;
    queue = new RequestQueue({
      idbQDb: idbHelper,
      config: {maxAge: MAX_AGE},
      queueName: QUEUE_NAME,
    });
    reqManager = new RequestManager({callbacks, queue});
    done();
  });

  describe(`constructor`, function() {
    it(`should initialize private methods with the given values iin constructor`, function() {
      expect(reqManager).to.be.an('object');
      expect(reqManager.attachSyncHandler).to.be.a('function');
      expect(reqManager.replayRequest).to.be.a('function');
      expect(reqManager.replayRequests).to.be.a('function');

      expect(reqManager._globalCallbacks).to.equal(callbacks);
      expect(reqManager._queue).to.equal(queue);
    });
  });

  describe(`replay method`, function() {
    it(`should replay all queued request via replay method`, async function() {
      sinon.spy(self, 'fetch');

      callbacks.replayDidSucceed = sinon.spy();
      callbacks.replayDidFail = sinon.spy();

    const backgroundSyncQueue = new Queue({callbacks});

    await backgroundSyncQueue.pushIntoQueue({
      request: new Request('/__echo/counter'),
    });
    await backgroundSyncQueue.pushIntoQueue({
      request: new Request('/__echo/counter'),
    });
    await backgroundSyncQueue._requestManager.replayRequests();

      // Asset replayDidSucceed callback was called with the correct arguments.
      expect(callbacks.replayDidSucceed.callCount).to.equal(2);
      expect(callbacks.replayDidSucceed.alwaysCalledWith(
          sinon.match.string, sinon.match.instanceOf(Response))).to.be.true;

      // Assert fetch was called for each replayed request.
      expect(self.fetch.calledTwice).to.be.true;

    await backgroundSyncQueue.pushIntoQueue({
      request: new Request('/__test/404'),
    });
    try {
      await backgroundSyncQueue._requestManager.replayRequests();
    } catch (err) {
      // Error is expected due to 404 response.
    }

      // Asset replayDidFail callback was called with the correct arguments.
      expect(callbacks.replayDidSucceed.callCount).to.equal(2);
      expect(callbacks.replayDidFail.callCount).to.equal(1);
      expect(callbacks.replayDidFail.alwaysCalledWith(
          sinon.match.string, sinon.match.instanceOf(Response))).to.be.ok;

      delete callbacks.replayDidSucceed;
      delete callbacks.replayDidFail;

      self.fetch.restore();
    });
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

describe(`request-queue`, function() {
  const QUEUE_NAME = 'QUEUE_NAME';
  const MAX_AGE = 6;

  const callbacks = {};
  const db = new IDBHelper(defaultDBName, 1, 'QueueStore');
  const queue = new RequestQueue({
    idbQDb: db,
    config: {maxAge: MAX_AGE},
    queueName: QUEUE_NAME,
    callbacks,
  });

  const resetDb = async function() {
    const keys = await db.getAllKeys();
    return Promise.all(keys.map((key) => db.delete(key)));
  };

  before(resetDb);
  afterEach(resetDb);

  describe(`constructor`, function() {
    it(`should initialize with correct object types`, function() {
      expect(queue).to.be.an('object');
      expect(queue._queue).to.be.an('array');
      expect(queue._queueName).to.be.a('string');
      expect(queue._config).to.be.an('object');
    });

    it(`should should not fail for null data`, async function() {
      expect(queue._queue.length).to.equal(0);
      db.put(queue._queueName, null);
      await queue.initQueue();
      expect(queue._queue.length).to.equal(0);
    });

    it(`should re-fill the queue`, async function() {
      expect(queue._queue.length).to.equal(0);
      const hash = await queue.push({
        request: new Request('http://lipsum.com/generate'),
      });
      expect(queue._queue.length).to.equal(1);
      queue._queue = [];
      expect(queue._queue.length).to.equal(0);
      await queue.initQueue();
      expect(queue._queue.length).to.equal(1);
      expect(queue._queue[0]).to.equal(hash);
    });

    it(`should fill the queueName correctly`, function() {
      expect(queue._queueName).to.equal(QUEUE_NAME);
    });

    it(`should configure correctly`, function() {
      expect(queue._config.maxAge).to.equal(MAX_AGE);
      expect(queue._config.maxAge).to.not
          .equal(maxAge);
    });

    it(`should configure correctly without any optional parameters given`, function() {
      let tempQueue = new RequestQueue({
        idbQDb: db,
      });
      let tempQueue2 = new RequestQueue({
        idbQDb: db,
      });
      expect(tempQueue._config).to.equal(undefined);
      expect(tempQueue._queueName).to.match(
        new RegExp(defaultQueueName + '_\\d+'));
      expect(tempQueue2._queueName).to.match(
        new RegExp(defaultQueueName + '_\\d+'));
    });
  });

  describe(`push method`, function() {
    it(`should push the Request given in the private array`, async function() {
      callbacks.requestWillEnqueue = sinon.spy();

      const queueLength = queue._queue.length;
      const hash = await queue.push({
        request: new Request('http://lipsum.com/generate'),
      });

      expect(hash).to.be.a('string');
      expect(queue._queue.length).to.equal(queueLength + 1);

      expect(callbacks.requestWillEnqueue.calledOnce).to.be.true;
      expect(callbacks.requestWillEnqueue.calledWith(sinon.match.has('request')))
          .to.be.true;

      delete callbacks.requestWillEnqueue;
    });
  });

  describe(`getRequestFromQueue method`, function() {
    it(`should get the proper Request back`, async function() {
      callbacks.requestWillDequeue = sinon.spy();

      const hash = await queue.push({
        request: new Request('http://lipsum.com/generate'),
      });

      const reqData = await queue.getRequestFromQueue({hash});

      expect(reqData).to.have.all.keys(['request', 'config', 'metadata']);
      expect(callbacks.requestWillDequeue.calledOnce).to.be.true;
      expect(callbacks.requestWillDequeue.calledWith(reqData)).to.be.true;

      delete callbacks.requestWillDequeue;
    });
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

describe(`response-manager`, function() {
  const response = 'VALUE';
  const idbHelper = new IDBHelper(defaultDBName, 1, 'QueueStore');

  it(`should be able to get the Response back from IDB of the given key`, () => {
    const queue = new Queue();
    return idbHelper.put('key', {response: response}).then(()=>{
        return queue.getResponse({id: 'key'}).then((data)=>{
            expect(data).to.equal(response);
        });
    });
  });

  it(`should be able to put the Response in IBD with the given key`, async function() {
    await putResponse({
      hash: 'somehash',
      idbObject: {},
      response: new Response(response),
      idbQDb: idbHelper,
    });
    const cachedResponse = await idbHelper.get('somehash');

    // Response is stored as BLOB, using FileReader to convert back
    const reader = new window.FileReader();
    reader.readAsText(cachedResponse.response.body);

    return new Promise((resolve) => {
      reader.onloadend = () => {
        const data = reader.result;
        expect(data).to.equal(response);
        resolve();
      };
    });
  });
});
//# sourceMappingURL=browser-bundle.js.map
